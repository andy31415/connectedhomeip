#!/usr/bin/env -S python3 -B

# Copyright (c) 2025 Project CHIP Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import logging
import subprocess
import sys

import click
import coloredlogs

# Supported log levels, mapping string values required for argument
# parsing into logging constants
__LOG_LEVELS__ = {
    "debug": logging.DEBUG,
    "info": logging.INFO,
    "warn": logging.WARN,
    "fatal": logging.FATAL,
}


@click.command()
@click.option(
    "--log-level",
    default="INFO",
    type=click.Choice([k for k in __LOG_LEVELS__.keys()], case_sensitive=False),
    help="Determines the verbosity of script output.",
)
@click.option(
    "--no-log-timestamps",
    default=False,
    is_flag=True,
    help="Skip timestaps in log output",
)
@click.option(
    "--binary",
    help="What is the binary that generated the coverage info",
)
@click.option(
    "--raw-profile",
    help="The *.profraw file that was generated by the binary",
)
def main(log_level, no_log_timestamps, binary, raw_profile):
    log_fmt = "%(asctime)s %(levelname)-7s %(message)s"
    if no_log_timestamps:
        log_fmt = "%(levelname)-7s %(message)s"
    coloredlogs.install(level=__LOG_LEVELS__[log_level], fmt=log_fmt)

    if not raw_profile.endswith(".profraw"):
        logging.error("Raw profile should end in .profraw")
        sys.exit(1)

    logging.info("Generating profdata from %s", raw_profile)
    subprocess.run(
        [
            "llvm-profdata",
            "merge",
            "-sparse",
            "-o",
            raw_profile.replace(".profraw", ".profdata"),
            raw_profile,
        ],
        check=True,
    )

    ignore_paths = [
        "third_party/boringssl/.*",
        "third_party/perfetto/.*",
        "third_party/jsoncpp/.*",
        "third_party/editline/.*",
        "third_party/initpp/.*",
        "third_party/libwebsockets/.*",
        "third_party/pigweed/.*",
        "third_party/nanopb/.*",
        "third_party/nl.*",
        "/usr/include/.*",
        "/usr/lib/.*",
        ".*/tests/.*" # do not report test coverage to not inflate numbers
    ]

    logging.info("Generating lcov file ...")
    cmd = [
        "llvm-cov",
        "export",
        "-format=lcov",
        "--instr-profile",
        raw_profile.replace(".profraw", ".profdata"),
        binary,
    ]

    for p in ignore_paths:
        cmd.extend(["-ignore-filename-regex", p])

    output = subprocess.run(cmd, capture_output=True)
    if output.returncode != 0:
        logging.error("Failed to execute `llvm-cov` !")
        logging.error("STDOUT:\n%s", output.stdout)
        logging.error("STDERR:\n%s", output.stderr)

        sys.exit(1)

    with open(raw_profile.replace(".profraw", ".lcov"), "wb") as f:
        f.write(output.stdout)


if __name__ == "__main__":
    main(auto_envvar_prefix="CHIP")
